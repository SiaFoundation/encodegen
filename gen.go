package main

import (
	"fmt"
	"go/format"
	"go/types"
	"golang.org/x/tools/go/packages"
	"io"
	"strings"
)

type generator struct {
	pkg         *packages.Package
	encodingPkg *packages.Package
	typs        map[string]string
	imports     []string
}

type SiaMarshaler interface {
	MarshalSia(w io.Writer) error
}
type SiaUnmarshaler interface {
	UnmarshalSia(r io.Reader) error
}

func (g *generator) addImport(pkg string) {
	for _, p := range g.imports {
		if p == pkg {
			return
		}
	}
	g.imports = append(g.imports, `"`+pkg+`"`)
}

func Generate(pkgName string, typs ...string) (string, error) {
	/*
		load source

		see https://stackoverflow.com/q/50197961
		import the encodegen packages at the same time as the user requested packages or types.implements breaks
	*/
	cfg := &packages.Config{Mode: packages.NeedName | packages.NeedTypes | packages.NeedImports}
	// pkgs[0] - user requested package; pkgs[1] - encodegen package;
	pkgs, err := packages.Load(cfg, pkgName, "go.sia.tech/encodegen")
	if err != nil {
		return "", err
	}

	/*
		these assignments (to siaMarshaler und siaUnmarshaler) are just for convenience in the error checking if statements.  I wasn't sure whether it was preferable to use global variables because they couldn't be done nicely using the var x = func(){...}() method.
		in genDecode/genEncode we do the lookup on encodePkg of SiaMarshaler and Unmarshaler.  I think this is preferable to having a siaMarshaler and siaUnmarshaler field on the struct.
	*/
	siaMarshaler := pkgs[1].Types.Scope().Lookup("SiaMarshaler")
	if siaMarshaler == nil || !types.IsInterface(siaMarshaler.Type()) {
		panic("no SiaMarshaler interface defined on encodegen package")
	}
	siaUnmarshaler := pkgs[1].Types.Scope().Lookup("SiaUnmarshaler")
	if siaUnmarshaler == nil || !types.IsInterface(siaUnmarshaler.Type()) {
		panic("no SiaUnmarshaler interface defined on encodegen package")
	}

	g := &generator{
		pkg:         pkgs[0],
		encodingPkg: pkgs[1],
		typs:        make(map[string]string),
	}
	g.addImport("io") // for io.Reader/io.Writer in method signatures
	g.addImport("gitlab.com/NebulousLabs/encoding")

	// check that all types are legal
	for _, typ := range typs {
		if err := g.checkType(typ); err != nil {
			return "", err
		}
	}

	// generate marshal/unmarshal methods for each specified type
	for _, typ := range typs {
		g.genMethods(typ)
	}

	// output
	var methods []string
	for _, code := range g.typs {
		methods = append(methods, code)
	}
	raw := fmt.Sprintf(`// Code generated by encodegen. DO NOT EDIT.
package %s
import (%s)

%s
`, g.pkg.Name, strings.Join(g.imports, ";"), strings.Join(methods, "\n"))

	// fmt.Printf("UNFORMATTED:\n%s\n", string(raw))

	formatted, err := format.Source([]byte(raw))
	if err != nil {
		panic(err) // should never happen
	}
	return string(formatted), nil
}

func (g *generator) checkType(typName string) error {
	var check func(t types.Type, ctx string) error
	check = func(t types.Type, ctx string) error {
		switch t := t.Underlying().(type) {
		case *types.Basic:
			if t.Info()&types.IsInteger != 0 || t.Kind() == types.Bool || t.Kind() == types.String {
				return nil
			}
		case *types.Array:
			return check(t.Elem(), ctx+"[0]")
		case *types.Slice:
			return check(t.Elem(), ctx+"[0]")
		case *types.Struct:
			for i := 0; i < t.NumFields(); i++ {
				field := t.Field(i)
				if err := check(field.Type(), ctx+"."+field.Name()); err != nil {
					return err
				}
			}
			return nil
		case *types.Pointer:
			return check(t.Elem(), "*"+ctx)
		}
		if ctx != "" {
			return fmt.Errorf("unsupported type %s at (%s)%s", t, typName, ctx)
		}
		return fmt.Errorf("unsupported type %s", t)
	}

	obj := g.pkg.Types.Scope().Lookup(typName)
	if obj == nil {
		return fmt.Errorf("no declaration found for type %q", typName)
	}
	return check(obj.Type(), "")
}

func (g *generator) genMethods(typName string) error {
	if _, ok := g.typs[typName]; ok {
		return nil // already generated
	}
	var enc, dec string
	switch t := g.pkg.Types.Scope().Lookup(typName).Type().Underlying().(type) {
	case *types.Basic:
		enc = g.genEncodeBody(t.Name()+"(x)", t)
		dec = g.genDecodeBody(t.Name()+"(x)", t)
	case *types.Array:
		enc = g.genEncodeBody("x", t)
		dec = g.genDecodeBody("x", t)
	case *types.Slice:
		enc = g.genEncodeBody("x", t)
		dec = g.genDecodeBody("x", t)
	case *types.Struct:
		for i := 0; i < t.NumFields(); i++ {
			field := t.Field(i)
			enc += g.genEncodeBody("x."+field.Name(), field.Type())
			dec += g.genDecodeBody("x."+field.Name(), field.Type())
		}
	default:
		// checkType should catch unhandled types, making this a developer error
		panic(fmt.Sprintf("unhandled type %T", t))
	}
	g.typs[typName] = fmt.Sprintf(`
// MarshalSia implements encoding.SiaMarshaler.
func (x %s) MarshalSia(w io.Writer) error {
	e := encoding.NewEncoder(w)
	%s
	return e.Err()
}

// UnmarshalSia implements encoding.SiaUnmarshaler.
func (x *%s) UnmarshalSia(r io.Reader) error {
	d := encoding.NewDecoder(r, encoding.DefaultAllocLimit)
	%s
	return d.Err()
}
`, typName, strings.TrimSpace(enc), typName, strings.TrimSpace(dec))
	return nil
}

func (g *generator) genEncodeBody(ident string, t types.Type) string {
	tOriginal := t
	switch t := t.Underlying().(type) {
	case *types.Basic:
		if t.Info()&types.IsInteger != 0 {
			return fmt.Sprintf("e.WriteUint64(%s)\n", cast(ident, t, types.Typ[types.Uint64]))
		} else if t.Kind() == types.Bool {
			return fmt.Sprintf("e.WriteBool(%s)\n", ident)
		} else if t.Kind() == types.String {
			return fmt.Sprintf("e.WritePrefixedBytes([]byte(%s))\n", ident)
		}
	case *types.Array:
		// check for [...]byte
		if basic, ok := t.Elem().(*types.Basic); ok && basic.Kind() == types.Byte {
			return fmt.Sprintf("e.Write(%s[:])\n", ident)
		}
		// NOTE: it's fine to always use "v" as the loop variable, even in
		// nested loops; the inner v will shadow the outer v, but inner
		// loops never need to reference the variables of outer loops.
		body := g.genEncodeBody("v", t.Elem())
		return fmt.Sprintf("for _, v := range &%s { %s }\n", ident, body)
	case *types.Slice:
		// check for []byte
		if basic, ok := t.Elem().(*types.Basic); ok && basic.Kind() == types.Byte {
			return fmt.Sprintf("e.WritePrefixedBytes(%s)\n", ident)
		}
		prefix := fmt.Sprintf("e.WriteInt(len(%s))\n", ident)
		body := g.genEncodeBody("v", t.Elem())
		return prefix + fmt.Sprintf("for _, v := range %s { %s }\n", ident, body)
	case *types.Struct:
		named, ok := tOriginal.(*types.Named)
		if !ok {
			// we don't have a named type, i.e. an anonymous struct
			var body string
			for i := 0; i < t.NumFields(); i++ {
				field := t.Field(i)
				body += g.genEncodeBody(ident+"."+field.Name(), field.Type())
			}
			return body
		} else {
			if named.Obj().Pkg() == g.pkg.Types {
				// if we're in the same package as the type, generate code for it
				g.genMethods(named.Obj().Name())
				return fmt.Sprintf("%s.MarshalSia(e)\n", ident)
			} else {
				if types.Implements(tOriginal, g.encodingPkg.Types.Scope().Lookup("SiaMarshaler").Type().Underlying().(*types.Interface)) {
					return fmt.Sprintf("%s.MarshalSia(e)\n", ident)
				} else {
					return fmt.Sprintf("e.Encode(%s)\n", ident)
				}
			}
		}
	case *types.Pointer:
		body := g.genEncodeBody(fmt.Sprintf("(*%s)", ident), t.Elem())
		return fmt.Sprintf("if %s != nil { e.WriteBool(true); %s; } else { e.WriteBool(false) } \n", ident, body)
	}
	panic("unreachable")
}

func (g *generator) genDecodeBody(ident string, t types.Type) string {
	tOriginal := t
	switch t := t.Underlying().(type) {
	case *types.Basic:
		if t.Info()&types.IsInteger != 0 {
			return fmt.Sprintf("%s = %s\n", ident, cast("d.NextUint64()", types.Typ[types.Uint64], t))
		} else if t.Kind() == types.Bool {
			return fmt.Sprintf("%s = %s(d.NextBool())\n", ident, t)
		} else if t.Kind() == types.String {
			return fmt.Sprintf("%s = %s(d.ReadPrefixedBytes())\n", ident, t)
		}
	case *types.Array:
		// check for [...]byte
		if basic, ok := t.Elem().(*types.Basic); ok && basic.Kind() == types.Byte {
			return fmt.Sprintf("d.Read(%s[:])\n", ident)
		}

		// NOTE: we can use the same variable shadowing trick as genEncodeBody,
		// but we have to use a pointer, so things are slightly uglier.
		body := g.genDecodeBody("(*v)", t.Elem())
		return fmt.Sprintf("for i := range %s { v := &%s[i]; %s }\n", ident, ident, body)
	case *types.Slice:
		// check for []byte
		if basic, ok := t.Elem().(*types.Basic); ok && basic.Kind() == types.Byte {
			return fmt.Sprintf("%s = %s(d.ReadPrefixedBytes())\n", ident, t)
		}

		/*
			by default imported types will be expressed using their full paths
			by using (*types.Package).Name as the qualifier we condense strings like go.sia.tech/encodegen/internal/test_imported.Imported to test_imported.Imported
			read more: https://github.com/golang/example/blob/master/gotypes/go-types.md#formatting-support
		*/
		typeString := types.TypeString(t, (*types.Package).Name)

		// if we have an imported type
		if named, ok := t.Elem().(*types.Named); ok {
			g.addImport(named.Obj().Pkg().Path())
		}

		prefix := fmt.Sprintf("%s = make(%s, d.NextPrefix(%d))\n", ident, typeString, sizeof(t.Elem()))
		body := g.genDecodeBody("(*v)", t.Elem())
		return prefix + fmt.Sprintf("for i := range %s {v := &%s[i]; %s}\n", ident, ident, body)
	case *types.Struct:
		named, ok := tOriginal.(*types.Named)
		if !ok {
			// anonymous struct
			var body string
			for i := 0; i < t.NumFields(); i++ {
				field := t.Field(i)
				body += g.genDecodeBody(ident+"."+field.Name(), field.Type())
			}
			return body
		} else {
			// if we're in the same package as the type, generate code for it
			if named.Obj().Pkg() == g.pkg.Types {
				g.genMethods(named.Obj().Name())
				return fmt.Sprintf("(&%s).UnmarshalSia(d)\n", ident)
			} else {
				// imported - check if we have unmarshalsia: if yes, use it, if not, use reflection
				// call types.NewPointer on original type because UnmarshalSia works on pointers of types
				if types.Implements(types.NewPointer(tOriginal), g.encodingPkg.Types.Scope().Lookup("SiaUnmarshaler").Type().Underlying().(*types.Interface)) {
					return fmt.Sprintf("(&%s).UnmarshalSia(d)\n", ident)
				} else {
					return fmt.Sprintf("d.Decode(&%s)\n", ident)
				}
			}
		}
	case *types.Pointer:
		// if we have an imported type
		if named, ok := t.Elem().(*types.Named); ok {
			g.addImport(named.Obj().Pkg().Path())
		}
		body := g.genDecodeBody(fmt.Sprintf("(*%s)", ident), t.Elem())
		return fmt.Sprintf("if d.NextBool() { %s = new(%s); %s }\n", ident, types.TypeString(t.Elem(), (*types.Package).Name), body)
	}
	panic("unreachable")
}

func sizeof(t types.Type) int {
	switch t := t.Underlying().(type) {
	case *types.Basic:
		if t.Info()&types.IsInteger != 0 {
			return 8
		} else if t.Kind() == types.Bool {
			return 1
		} else if t.Kind() == types.String {
			return 8
		}
	case *types.Array:
		return int(t.Len()) * sizeof(t.Elem())
	case *types.Slice:
		return 8
	case *types.Struct:
		var total int
		for i := 0; i < t.NumFields(); i++ {
			total += sizeof(t.Field(i).Type())
		}
		return total
	case *types.Pointer:
		// sizeof the true/false for whether its null or not
		return 1
	}
	panic("unreachable")
}

func cast(ident string, from types.Type, to types.Type) string {
	/*
		I *think* types.AssignableTo might be preferable here, but we should
		check that it doesn't skip any casts that are actually necessary
	*/
	if types.Identical(from, to) {
		return ident
	}
	return fmt.Sprintf("%s(%s)", types.TypeString(to, (*types.Package).Name), ident)
}
