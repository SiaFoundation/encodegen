package test

import (
	"bytes"
	"gitlab.com/NebulousLabs/encoding"
	"go.sia.tech/encodegen/test/imported"
	"io"
	"reflect"
	"testing"
)

/*
Separate directory for tests so that generated source output does not pollute the main source directory

Functions for test types must be generated for these types to work.
*/

// all types that have generated code on them implement this interface
type SiaMarshaler interface {
	MarshalSia(w io.Writer) error
}

// implemented on pointers of objects
type SiaUnmarshaler interface {
	UnmarshalSia(r io.Reader) error
}

func TestSimpleMessage(t *testing.T) {
	simpleMessage := TestMessageSimple{
		A: 5,
		B: 4,
		C: 3,
		D: 2,
		E: true,
		F: [32]Hash{},
		G: []byte{1, 1, 1, 1, 0},
		H: imported.Imported{A: 5, B: "AAA", C: true},
		I: new(uint64),
		J: &imported.Imported{A: 555, B: "AAA", C: false},
		K: new(**uint64),
		L: []*imported.Imported{nil, nil, nil},
	}
	messageBytes := compareMarshal(t, simpleMessage)
	compareUnmarshal(t, messageBytes, &TestMessageSimple{}, &TestMessageSimple{})

	embeddedMessage := TestMessageEmbedded{
		A: struct {
			A uint64
			B uint32
			C uint16
			D uint8
			E int8
			F bool
			G []byte
			H struct {
				I []int
			}
		}{
			A: 1,
			B: 1,
			C: 1,
			D: 1,
			E: 1,
			F: false,
			G: []byte{0, 1, 2, 3, 4},
			H: struct{ I []int }{I: []int{99, 0, 99}},
		},
	}
	messageBytes = compareMarshal(t, embeddedMessage)
	compareUnmarshal(t, messageBytes, &TestMessageEmbedded{}, &TestMessageEmbedded{})
}

func compareMarshal(t *testing.T, obj interface{}) []byte {
	impl, ok := obj.(SiaMarshaler)
	if !ok {
		t.Fatal("Type does not implement SiaMarshaler.  Make sure to generate the code before running these tests.")
	}

	bufferUnofficial := &bytes.Buffer{}
	impl.MarshalSia(bufferUnofficial)

	bytesOfficial := encoding.Marshal(obj)

	if !reflect.DeepEqual(bytesOfficial, bufferUnofficial.Bytes()) {
		t.Fatalf("Generated buffer (%+v) does not equal one generated by reflection (%+v)", bufferUnofficial.Bytes(), bytesOfficial)
	}
	return bytesOfficial
}

func compareUnmarshal(t *testing.T, marshaledBytes []byte, obj1 interface{}, obj2 interface{}) {
	impl, ok := obj1.(SiaUnmarshaler)
	if !ok {
		t.Fatal("Type does not implement SiaUnmarshaler.  Make sure to generate the code before running these tests.")
	}

	impl.UnmarshalSia(bytes.NewReader(marshaledBytes))
	encoding.Unmarshal(marshaledBytes, obj2)

	if !reflect.DeepEqual(obj2, impl) {
		t.Fatalf("Unmarshaled object (%+v) does not equal one generated by NebulousLabs/encoding (%+v).", impl, obj2)
	}
}
