package codegen

import (
	"bytes"
	"fmt"
	"github.com/bradfitz/iter"
	"strings"
	"text/template"
)

const (
	decodeBaseType = iota
	encodeBaseType
	decodeBaseTypeSlice
	encodeBaseTypeSlice
	decodeRawType
	encodeRawType
	decodeStruct
	encodeStruct

	decodeStructSlice
	encodeStructSlice

	// decodeUnknown
	// encodeUnknown

	resetFieldValue
	poolInstanceRelease
	poolSliceInstanceRelease
)

var fieldTemplate = map[int]string{
	decodeBaseType: `
{{if .IsPointer}}
	if b.readBool() {
		{{.Accessor}} = new({{.Type}})
		*{{.Accessor}} = {{.Type}}(b.{{.DecodingMethod}}())
	}
{{else}}
	{{.Accessor}} = {{.Type}}(b.{{.DecodingMethod}}())
{{end}}
`,
	encodeBaseType: `
{{if .IsPointer}}
	if {{.Accessor}} != nil {
		b.writeBool(true)
{{end}}

	b.{{.EncodingMethod}}({{.PrimitiveWriteCast}}({{if .IsPointer}}*{{end}}{{.Accessor}}))

{{if .IsPointer}}
	} else {
		b.writeBool(false)
	}
{{end}}
`,

	decodeBaseTypeSlice: `

{{if .IsPointer}}
	if b.readBool() {
{{end}}

{{.Accessor}} = make({{.Type}}, int(b.readUint64()))

for i := range {{.Accessor}} {

	{{if .IsPointerComponent}}
	if b.readBool() {
		{{.Accessor}}[i] = new({{.ComponentType}})
		*{{.Accessor}}[i] = {{noPointer .ComponentType}}(b.{{.DecodingMethod}}())
	}
	{{else}}
		{{.Accessor}}[i] = {{.ComponentType}}(b.{{.DecodingMethod}}())
	{{end}}

}

{{if .IsPointer}}
}
{{end}}

`,
	encodeBaseTypeSlice: `
{{if .IsPointer}}
	if {{.Accessor}} != nil {
	b.writeBool(true)
{{end}}
	b.writeUint64(len({{if .IsPointer}}*{{end}}{{.Accessor}}))

	for i := range {{if .IsPointer}}*{{end}}{{.Accessor}} {
		{{if .IsPointerComponent}}
		if {{.Accessor}}[i] != nil {
			b.writeBool(true)

			b.{{.EncodingMethod}}({{.PrimitiveWriteCast}}(*{{.Accessor}}[i]))

		{{else}}
			b.{{.EncodingMethod}}({{.Accessor}}[i])
		{{end}}

		{{if .IsPointerComponent}}
		} else {
			b.writeBool(false)
		}
		{{end}}
	}

{{if .IsPointer}}
} else {
	b.writeBool(false)
}
{{end}}
`,
	decodeStruct: `

(*{{.Type}})(&{{.Accessor}}).unmarshalBuffer(b)

`,
	encodeStruct: `

	{{.Accessor}}.marshalBuffer(b)
`,

	decodeStructSlice: `
{{if .IsPointer}}
	if b.readBool() {
{{end}}

{{.Accessor}} = make({{.RawType}}, int(b.readUint64()))

for i := range {{.Accessor}} {

	{{if .IsPointerComponent}}
	if b.readBool() {
		{{.Accessor}}[i] = new({{.ComponentType}})
		{{.Accessor}}[i].unmarshalBuffer(b)
	}
	{{else}}
		({{.Type}})(&{{.Accessor}}[i]).unmarshalBuffer(b)
	{{end}}
}

{{if .IsPointer}}
}
{{end}}
`,

	encodeStructSlice: `

{{if .IsPointer}}
	if {{.Accessor}} != nil {
	b.writeBool(true)
{{end}}
	b.writeUint64(len({{if .IsPointer}}*{{end}}{{.Accessor}}))

	for i := range {{if .IsPointer}}*{{end}}{{.Accessor}} {
		{{if .IsPointerComponent}}
		if {{.Accessor}}[i] != nil {
			b.writeBool(true)
		{{end}}

		{{.Accessor}}[i].marshalBuffer(b)

		{{if .IsPointerComponent}}
		} else {
			b.writeBool(false)
		}
		{{end}}
	}

{{if .IsPointer}}
} else {
	b.writeBool(false)
}
{{end}}

`,
	poolInstanceRelease: `	{{.PoolName}}.Put({{.Accessor}})`,

	poolSliceInstanceRelease: `	for i := range {{.Accessor}} {
        {{.Accessor}}[i].Reset()
		{{.PoolName}}.Put({{.PointerModifier}}{{.Accessor}}[i])
    }`,
}

const (
	fileCode = iota
	encodingStructType
	baseTypeSlice
	structTypeSlice
	resetStruct
	poolVar
	poolInit
	embeddedStructInit
	typeSlice
)

var blockTemplate = map[int]string{
	fileCode: `// Code generated by Gojay. DO NOT EDIT.

package {{.Pkg}}

import (
	{{.Imports}}
)
{{if .Init}}
func init() {
{{.Init}}
}
{{end}}
{{.Code}}
`,
	encodingStructType: `// MarshalBuffer implements MarshalerBuffer

func ({{.Receiver}}) MarshalBuffer(b *objBuffer) {
{{.EncodingCases}}
}

// UnmarshalBuffer implements gojay's UnmarshalerBuffer
func ({{.Receiver}}) UnmarshalBuffer(b *objBuffer) error {
{{.InitEmbedded}}
{{.DecodingCases}}	
	return b.Err()
}


{{.Reset}}

`,
	resetStruct: `
// Reset reset fields 
func ({{.Receiver}}) Reset()  {
{{.Reset}}
}
`,

	poolVar: `var {{.PoolName}} *sync.Pool`,
	poolInit: `	{{.PoolName}} = &sync.Pool {
		New: func()interface{} {
			return &{{.Type}}{}
		},
	}`,
	embeddedStructInit: `if {{.Accessor}} == nil { 
		{{.Accessor}} = {{.Init}}
	}`,
}

// for the template
func minus(a int, b int) int {
	return a - b
}

func plus(a int, b int) int {
	return a + b
}

func noPointer(s string) string {
	return strings.Replace(s, "*", "", -1)
}

func expandTemplate(namespace string, dictionary map[int]string, key int, data interface{}) (string, error) {
	var id = fmt.Sprintf("%v_%v", namespace, key)
	textTemplate, ok := dictionary[key]
	if !ok {
		return "", fmt.Errorf("failed to lookup template for %v.%v", namespace, key)
	}
	// add iter function to allow us to conveniently repeat code n times
	temlate, err := template.New(id).Funcs(template.FuncMap{"N": iter.N, "minus": minus, "plus": plus, "noPointer": noPointer}).Parse(textTemplate)
	if err != nil {
		return "", fmt.Errorf("fiailed to parse template %v %v, due to %v", namespace, key, err)
	}
	writer := new(bytes.Buffer)
	err = temlate.Execute(writer, data)
	return writer.String(), err
}

func expandFieldTemplate(key int, data interface{}) (string, error) {
	return expandTemplate("fieldTemplate", fieldTemplate, key, data)
}

func expandBlockTemplate(key int, data interface{}) (string, error) {
	return expandTemplate("blockTemplate", blockTemplate, key, data)
}
