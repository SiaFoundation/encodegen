package codegen

import (
	"bytes"
	"fmt"
	"github.com/bradfitz/iter"
	"path/filepath"
	"strings"
	"text/template"
)

const (
	decodeBaseType = iota
	encodeBaseType
	decodeBaseTypeSlice
	encodeBaseTypeSlice
	decodeRawType
	encodeRawType
	decodeStruct
	encodeStruct

	decodeStructSlice
	encodeStructSlice
)

var fieldTemplate = map[int]string{
	decodeBaseType: `
{{if .IsPointer}}
	if b.ReadBool() {
		if ({{.Accessor}} == nil) {
			{{.Accessor}} = new({{.Type}})
		}
		*{{.Accessor}} = {{.Type}}(b.{{.DecodingMethod}}())
	}
{{else}}
	{{.Accessor}} = {{.Type}}(b.{{.DecodingMethod}}())
{{end}}
`,
	encodeBaseType: `
{{if .IsPointer}}
	if {{.Accessor}} != nil {
		b.WriteBool(true)
{{end}}

	b.{{.EncodingMethod}}({{if .PrimitiveWriteCastEnabled}}{{.PrimitiveWriteCast}}{{end}}({{if .IsPointer}}*{{end}}{{.Accessor}}))

{{if .IsPointer}}
	} else {
		b.WriteBool(false)
	}
{{end}}
`,

	decodeBaseTypeSlice: `

{{.Accessor}} = make({{.Type}}, int(b.ReadUint64()))

for i := range {{.Accessor}} {

	{{if .IsPointerComponent}}
	if b.ReadBool() {
		if ({{.Accessor}}[i] == nil) {
			{{.Accessor}}[i] = new({{.ComponentType}})		
		}
		*{{.Accessor}}[i] = {{noPointer .ComponentType}}(b.{{.DecodingMethod}}())
	}
	{{else}}
		{{.Accessor}}[i] = {{.ComponentType}}(b.{{.DecodingMethod}}())
	{{end}}

}

`,
	encodeBaseTypeSlice: `

b.WriteUint64(uint64(len({{if .IsPointer}}*{{end}}{{.Accessor}})))

for i := range {{if .IsPointer}}*{{end}}{{.Accessor}} {
	{{if .IsPointerComponent}}
	if {{.Accessor}}[i] != nil {
		b.WriteBool(true)

		b.{{.EncodingMethod}}({{if .PrimitiveWriteCastEnabled}}{{.PrimitiveWriteCast}}{{end}}(*{{.Accessor}}[i]))

	{{else}}
		b.{{.EncodingMethod}}({{if .PrimitiveWriteCastEnabled}}{{.PrimitiveWriteCast}}{{end}}({{.Accessor}}[i]))
	{{end}}

	{{if .IsPointerComponent}}
	} else {
		b.WriteBool(false)
	}
	{{end}}
}

`,
	decodeStruct: `

{{if .IsPointer}}
	if b.ReadBool() {
		if ({{.Accessor}} == nil) {
			{{.Accessor}} = new({{.Type}})
		}
		(*{{.Type}})({{.Accessor}}).UnmarshalBuffer(b)	
	}
{{else}}
	(*{{.Type}})(&{{.Accessor}}).UnmarshalBuffer(b)
{{end}}
`,
	encodeStruct: `

{{if .IsPointer}}
	if {{.Accessor}} != nil {
		b.WriteBool(true)
		(*{{.Type}})({{.Accessor}}).MarshalBuffer(b)
	} else {
		b.WriteBool(false)
	}
{{else}}
	(*{{.Type}})(&{{.Accessor}}).MarshalBuffer(b)
{{end}}
`,

	decodeStructSlice: `

{{.Accessor}} = make({{.RawType}}, int(b.ReadUint64()))

for i := range {{.Accessor}} {

	{{if .IsPointerComponent}}
	if b.ReadBool() {
		if ({{.Accessor}}[i] == nil) {
			{{.Accessor}}[i] = new({{.ComponentType}})
		}
		{{.Accessor}}[i].UnmarshalBuffer(b)
	}
	{{else}}
		(*{{.ComponentType}})(&{{.Accessor}}[i]).UnmarshalBuffer(b)
	{{end}}
}


`,

	encodeStructSlice: `

	b.WriteUint64(uint64(len({{if .IsPointer}}*{{end}}{{.Accessor}})))

	for i := range {{if .IsPointer}}*{{end}}{{.Accessor}} {
		{{if .IsPointerComponent}}
		if {{.Accessor}}[i] != nil {
			b.WriteBool(true)
		{{end}}

		{{.Accessor}}[i].MarshalBuffer(b)

		{{if .IsPointerComponent}}
		} else {
			b.WriteBool(false)
		}
		{{end}}
	}

`,
}

const (
	fileCode = iota
	encodingStructType
	baseTypeSlice
	structTypeSlice
	embeddedStructInit
	typeSlice
)

var blockTemplate = map[int]string{
	fileCode: `// Code generated by encodegen. DO NOT EDIT.

package {{base .Pkg}}

import (
	{{.Imports}}
)
{{if .Init}}
func init() {
{{.Init}}
}
{{end}}
{{.Code}}
`,
	encodingStructType: `// MarshalBuffer implements MarshalerBuffer

func ({{.Receiver}}) MarshalBuffer(b *encodegen.ObjBuffer) {
{{.EncodingCases}}
}

// UnmarshalBuffer implements encodegen's UnmarshalerBuffer
func ({{.Receiver}}) UnmarshalBuffer(b *encodegen.ObjBuffer) error {
{{.InitEmbedded}}
{{.DecodingCases}}	
	return b.Err()
}`,
embeddedStructInit: `if {{.Accessor}} == nil { 
		{{.Accessor}} = {{.Init}}
	}`,
}

// for the template
func minus(a int, b int) int {
	return a - b
}

func plus(a int, b int) int {
	return a + b
}

func noPointer(s string) string {
	return strings.Replace(s, "*", "", -1)
}

func expandTemplate(namespace string, dictionary map[int]string, key int, data interface{}) (string, error) {
	var id = fmt.Sprintf("%v_%v", namespace, key)
	textTemplate, ok := dictionary[key]
	if !ok {
		return "", fmt.Errorf("failed to lookup template for %v.%v", namespace, key)
	}
	// add iter function to allow us to conveniently repeat code n times
	temlate, err := template.New(id).Funcs(template.FuncMap{"N": iter.N, "minus": minus, "plus": plus, "noPointer": noPointer, "base": filepath.Base}).Parse(textTemplate)
	if err != nil {
		return "", fmt.Errorf("fiailed to parse template %v %v, due to %v", namespace, key, err)
	}
	writer := new(bytes.Buffer)
	err = temlate.Execute(writer, data)
	return writer.String(), err
}

func expandFieldTemplate(key int, data interface{}) (string, error) {
	return expandTemplate("fieldTemplate", fieldTemplate, key, data)
}

func expandBlockTemplate(key int, data interface{}) (string, error) {
	return expandTemplate("blockTemplate", blockTemplate, key, data)
}
