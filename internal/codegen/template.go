package codegen

import (
	"bytes"
	"fmt"
	"github.com/bradfitz/iter"
	"text/template"
)

const (
	decodeBaseType = iota
	encodeBaseType
	decodeBaseTypeSlice
	encodeBaseTypeSlice
	decodeRawType
	encodeRawType
	decodeStruct
	encodeStruct

	decodeStructSlice
	encodeStructSlice

	// decodeUnknown
	// encodeUnknown

	resetFieldValue
	poolInstanceRelease
	poolSliceInstanceRelease
)

var fieldTemplate = map[int]string{
	decodeBaseType: `
{{range $i, $_ := N .LeftStarCount}}
if b.readBool() {
{{end}}

{{if .IsPointer}}

{{.Accessor}} = new({{range $i, $_ := N (minus .LeftStarCount 1)}}*{{end}}{{.Type}})
{{range $i, $_ := N .LeftStarCount}}*{{end}}({{.Accessor}}) = {{.Type}}(b.{{.DecodingMethod}}())

{{else}}
	{{.Accessor}} = {{.Type}}(b.{{.DecodingMethod}}())
{{end}}

{{range $i, $_ := N .LeftStarCount}}
}
{{end}}

`,
	encodeBaseType: `
{{$item:=.}}

{{range $i, $_ := N .LeftStarCount}}
if {{range $j, $_ := N $i}}*{{end}}{{$item.Accessor}} != nil {
	b.writeBool(true)
{{end}}

b.{{.EncodingMethod}}({{.PrimitiveWriteCast}}({{range $i, $_ := N .LeftStarCount}}*{{end}}{{.Accessor}}))

{{range $i, $_ := N .LeftStarCount}}

} else {
	b.writeBool(false)
}

{{end}}

`,

	decodeBaseTypeSlice: `
			{{.Accessor}} = make({{.Type}}, int(b.readUint64()))
			for i := range {{.Accessor}} {
				{{.Accessor}}[i] = {{.ComponentType}}(b.{{.DecodingMethod}}())
			}
`,
	encodeBaseTypeSlice: `
for i := range {{.Accessor}} {
	b.{{.EncodingMethod}}({{.PrimitiveWriteCast}}({{.Accessor}}[i]))
}

`,
	decodeStruct: `
{{range $i, $_ := N .LeftStarCount}}
if b.readBool() {
{{end}}

(*{{.Type}})(&{{.Accessor}}).unmarshalBuffer(b)

{{range $i, $_ := N .LeftStarCount}}
}
{{end}}

`,
	encodeStruct: `
{{range $i, $_ := N .LeftStarCount}}
if 
{{end}}

	{{.Accessor}}.marshalBuffer(b)
`,

	decodeStructSlice: `
			{{.Accessor}} = make({{.RawType}}, int(b.readUint64()))
			for i := range {{.Accessor}} {
				(*{{.ComponentType}})(&{{.Accessor}}[i]).unmarshalBuffer(b)

			}
`,

	encodeStructSlice: `
for i := range {{.Accessor}} {
	{{.Accessor}}[i].marshalBuffer(b)
}

`,
	poolInstanceRelease: `	{{.PoolName}}.Put({{.Accessor}})`,

	poolSliceInstanceRelease: `	for i := range {{.Accessor}} {
        {{.Accessor}}[i].Reset()
		{{.PoolName}}.Put({{.PointerModifier}}{{.Accessor}}[i])
    }`,
}

const (
	fileCode = iota
	encodingStructType
	baseTypeSlice
	structTypeSlice
	resetStruct
	poolVar
	poolInit
	embeddedStructInit
	typeSlice
)

var blockTemplate = map[int]string{
	fileCode: `// Code generated by Gojay. DO NOT EDIT.


package {{.Pkg}}

import (
	{{.Imports}}
)
{{if .Init}}
func init() {
{{.Init}}
}
{{end}}
{{.Code}}
`,
	encodingStructType: `// MarshalBuffer implements MarshalerBuffer
func ({{.Receiver}}) MarshalBuffer(b *objBuffer) {
{{.EncodingCases}}
}

// UnmarshalBuffer implements gojay's UnmarshalerBuffer
func ({{.Receiver}}) UnmarshalBuffer(b *objBuffer) error {
{{.InitEmbedded}}
{{.DecodingCases}}	
	return b.Err()
}


{{.Reset}}

`,
	resetStruct: `
// Reset reset fields 
func ({{.Receiver}}) Reset()  {
{{.Reset}}
}
`,

	poolVar: `var {{.PoolName}} *sync.Pool`,
	poolInit: `	{{.PoolName}} = &sync.Pool {
		New: func()interface{} {
			return &{{.Type}}{}
		},
	}`,
	embeddedStructInit: `if {{.Accessor}} == nil { 
		{{.Accessor}} = {{.Init}}
	}`,
}

// for the template
func minus(a int, b int) int {
	return a - b
}

func plus(a int, b int) int {
	return a + b
}

func expandTemplate(namespace string, dictionary map[int]string, key int, data interface{}) (string, error) {
	var id = fmt.Sprintf("%v_%v", namespace, key)
	textTemplate, ok := dictionary[key]
	if !ok {
		return "", fmt.Errorf("failed to lookup template for %v.%v", namespace, key)
	}
	// add iter function to allow us to conveniently repeat code n times
	temlate, err := template.New(id).Funcs(template.FuncMap{"N": iter.N, "minus": minus, "plus": plus}).Parse(textTemplate)
	if err != nil {
		return "", fmt.Errorf("fiailed to parse template %v %v, due to %v", namespace, key, err)
	}
	writer := new(bytes.Buffer)
	err = temlate.Execute(writer, data)
	return writer.String(), err
}

func expandFieldTemplate(key int, data interface{}) (string, error) {
	return expandTemplate("fieldTemplate", fieldTemplate, key, data)
}

func expandBlockTemplate(key int, data interface{}) (string, error) {
	return expandTemplate("blockTemplate", blockTemplate, key, data)
}
