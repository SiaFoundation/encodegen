// Code generated by encodegen. DO NOT EDIT.
package basic_struct

import (
	encoding "gitlab.com/NebulousLabs/encoding"
	importedtyperename "go.sia.tech/encodegen/internal/codegen/test/importedtype"
	encodegen "go.sia.tech/encodegen/pkg/encodegen"
)

var (
	EncodegenSizeofEmptyMessage    = len(encoding.Marshal(Message{}))
	EncodegenSizeofEmptySubMessage = len(encoding.Marshal(SubMessage{}))
)

// MarshalBuffer implements MarshalerBuffer
func (m *Message) MarshalBuffer(b *encodegen.ObjBuffer) {
	if m != nil {

		b.WriteUint64(uint64(m.Id))

		b.WriteString((m.Name))

		b.WriteUint64(uint64(len(m.Ints)))
		for i := range m.Ints {
			b.WriteUint64(uint64(m.Ints[i]))
		}

		b.WriteUint64(uint64(m.Uint8))

		b.WriteUint64(uint64(len(m.Uint8s)))
		b.Write(m.Uint8s)

		if m.SubMessageX != nil {
			b.WriteBool(true)
			(*SubMessage)(m.SubMessageX).MarshalBuffer(b)
		} else {
			b.WriteBool(false)
		}

		b.WriteUint64(uint64(len(m.MessagesX)))
		for i := range m.MessagesX {
			if m.MessagesX[i] != nil {
				b.WriteBool(true)
				m.MessagesX[i].MarshalBuffer(b)
			} else {
				b.WriteBool(false)
			}
		}

		(*SubMessage)(&m.SubMessageY).MarshalBuffer(b)

		b.WriteUint64(uint64(len(m.MessagesY)))
		for i := range m.MessagesY {
			m.MessagesY[i].MarshalBuffer(b)
		}

		if m.IsTrue != nil {
			b.WriteBool(true)
			b.WriteBool((*m.IsTrue))
		} else {
			b.WriteBool(false)
		}

		b.WriteUint64(uint64(len(m.Payload)))
		b.Write(m.Payload)

		b.WriteUint64(uint64(len(m.Strings)))
		for i := range m.Strings {
			b.WriteString((m.Strings[i]))
		}

		b.Write(m.FixedBytes[:])

		for i := range m.FixedInts {
			b.WriteUint64(uint64(m.FixedInts[i]))
		}

		for i := range m.FixedIntPointers {
			if m.FixedIntPointers[i] != nil {
				b.WriteBool(true)
				b.WriteUint64(uint64(*m.FixedIntPointers[i]))
			} else {
				b.WriteBool(false)
			}
		}

		b.Write(m.FixedUint8s[:])

		for i := range m.FixedSubMessage {
			m.FixedSubMessage[i].MarshalBuffer(b)
		}

		for i := range m.FixedPointerSubMessage {
			if m.FixedPointerSubMessage[i] != nil {
				b.WriteBool(true)
				m.FixedPointerSubMessage[i].MarshalBuffer(b)
			} else {
				b.WriteBool(false)
			}
		}

		(*importedtyperename.Imported)(&m.Imported).MarshalBuffer(b)

		if m.ImportedPointer != nil {
			b.WriteBool(true)
			(*importedtyperename.Imported)(m.ImportedPointer).MarshalBuffer(b)
		} else {
			b.WriteBool(false)
		}

		b.WriteUint64(uint64(len(m.ImportedSlice)))
		for i := range m.ImportedSlice {
			m.ImportedSlice[i].MarshalBuffer(b)
		}

		b.WriteUint64(uint64(len(m.ImportedPointerSlice)))
		for i := range m.ImportedPointerSlice {
			if m.ImportedPointerSlice[i] != nil {
				b.WriteBool(true)
				m.ImportedPointerSlice[i].MarshalBuffer(b)
			} else {
				b.WriteBool(false)
			}
		}

		for i := range m.FixedImported {
			m.FixedImported[i].MarshalBuffer(b)
		}

		for i := range m.FixedPointerImported {
			if m.FixedPointerImported[i] != nil {
				b.WriteBool(true)
				m.FixedPointerImported[i].MarshalBuffer(b)
			} else {
				b.WriteBool(false)
			}
		}

	}
}

// UnmarshalBuffer implements encodegen's UnmarshalerBuffer
func (m *Message) UnmarshalBuffer(b *encodegen.ObjBuffer) error {
	if m != nil {
		var length int = 0
		_ = length

		m.Id = int(b.ReadUint64())

		m.Name = string(b.ReadString())

		length = int(b.ReadPrefix(8))
		if length > 0 {
			if len(m.Ints) < length {
				m.Ints = make([]int, length)
			}
			m.Ints = m.Ints[:length]
			for i := range m.Ints {
				m.Ints[i] = int((b.ReadUint64()))
			}
		}

		m.Uint8 = uint8(b.ReadUint64())

		length = int(b.ReadPrefix(1))
		if length > 0 {
			if len(m.Uint8s) < length {
				m.Uint8s = make([]uint8, length)
			}
			m.Uint8s = m.Uint8s[:length]
			b.Read(m.Uint8s)
		}

		if b.ReadBool() {
			if m.SubMessageX == nil {
				m.SubMessageX = new(SubMessage)
			}
			(*SubMessage)(m.SubMessageX).UnmarshalBuffer(b)
		}

		length = int(b.ReadUint64())
		if length > 0 {
			if len(m.MessagesX) < length {
				m.MessagesX = make([]*SubMessage, length)
			}
			m.MessagesX = m.MessagesX[:length]
			for i := range m.MessagesX {
				if b.ReadBool() {
					if m.MessagesX[i] == nil {
						m.MessagesX[i] = new(SubMessage)
					}
					m.MessagesX[i].UnmarshalBuffer(b)
				}
			}
		}

		(*SubMessage)(&m.SubMessageY).UnmarshalBuffer(b)

		length = int(b.ReadUint64())
		if length > 0 {
			if len(m.MessagesY) < length {
				m.MessagesY = make([]SubMessage, length)
			}
			m.MessagesY = m.MessagesY[:length]
			for i := range m.MessagesY {
				(*SubMessage)(&m.MessagesY[i]).UnmarshalBuffer(b)
			}
		}

		if b.ReadBool() {
			if m.IsTrue == nil {
				m.IsTrue = new(bool)
			}
			*m.IsTrue = bool((b.ReadBool()))
		}

		length = int(b.ReadPrefix(1))
		if length > 0 {
			if len(m.Payload) < length {
				m.Payload = make([]byte, length)
			}
			m.Payload = m.Payload[:length]
			b.Read(m.Payload)
		}

		length = int(b.ReadPrefix(1))
		if length > 0 {
			if len(m.Strings) < length {
				m.Strings = make([]string, length)
			}
			m.Strings = m.Strings[:length]
			for i := range m.Strings {
				m.Strings[i] = string((b.ReadString()))
			}
		}

		b.Read(m.FixedBytes[:])

		for i := range m.FixedInts {
			m.FixedInts[i] = int((b.ReadUint64()))
		}

		for i := range m.FixedIntPointers {
			if b.ReadBool() {
				if m.FixedIntPointers[i] == nil {
					m.FixedIntPointers[i] = new(int)
				}
				*m.FixedIntPointers[i] = int((b.ReadUint64()))
			}
		}

		b.Read(m.FixedUint8s[:])

		for i := range m.FixedSubMessage {
			(*SubMessage)(&m.FixedSubMessage[i]).UnmarshalBuffer(b)
		}

		for i := range m.FixedPointerSubMessage {
			if b.ReadBool() {
				if m.FixedPointerSubMessage[i] == nil {
					m.FixedPointerSubMessage[i] = new(SubMessage)
				}
				m.FixedPointerSubMessage[i].UnmarshalBuffer(b)
			}
		}

		(*importedtyperename.Imported)(&m.Imported).UnmarshalBuffer(b)

		if b.ReadBool() {
			if m.ImportedPointer == nil {
				m.ImportedPointer = new(importedtyperename.Imported)
			}
			(*importedtyperename.Imported)(m.ImportedPointer).UnmarshalBuffer(b)
		}

		length = int(b.ReadUint64())
		if length > 0 {
			if len(m.ImportedSlice) < length {
				m.ImportedSlice = make([]importedtyperename.Imported, length)
			}
			m.ImportedSlice = m.ImportedSlice[:length]
			for i := range m.ImportedSlice {
				(*importedtyperename.Imported)(&m.ImportedSlice[i]).UnmarshalBuffer(b)
			}
		}

		length = int(b.ReadUint64())
		if length > 0 {
			if len(m.ImportedPointerSlice) < length {
				m.ImportedPointerSlice = make([]*importedtyperename.Imported, length)
			}
			m.ImportedPointerSlice = m.ImportedPointerSlice[:length]
			for i := range m.ImportedPointerSlice {
				if b.ReadBool() {
					if m.ImportedPointerSlice[i] == nil {
						m.ImportedPointerSlice[i] = new(importedtyperename.Imported)
					}
					m.ImportedPointerSlice[i].UnmarshalBuffer(b)
				}
			}
		}

		for i := range m.FixedImported {
			(*importedtyperename.Imported)(&m.FixedImported[i]).UnmarshalBuffer(b)
		}

		for i := range m.FixedPointerImported {
			if b.ReadBool() {
				if m.FixedPointerImported[i] == nil {
					m.FixedPointerImported[i] = new(importedtyperename.Imported)
				}
				m.FixedPointerImported[i].UnmarshalBuffer(b)
			}
		}

	}
	return b.Err()
}

// MarshalBuffer implements MarshalerBuffer
func (m *SubMessage) MarshalBuffer(b *encodegen.ObjBuffer) {
	if m != nil {

		b.WriteUint64(uint64(m.Id))

		b.WriteString((m.Description))

		b.WriteUint64(uint64(len(m.Strings)))
		for i := range m.Strings {
			b.WriteString((m.Strings[i]))
		}

	}
}

// UnmarshalBuffer implements encodegen's UnmarshalerBuffer
func (m *SubMessage) UnmarshalBuffer(b *encodegen.ObjBuffer) error {
	if m != nil {
		var length int = 0
		_ = length

		m.Id = int(b.ReadUint64())

		m.Description = string(b.ReadString())

		length = int(b.ReadPrefix(1))
		if length > 0 {
			if len(m.Strings) < length {
				m.Strings = make([]string, length)
			}
			m.Strings = m.Strings[:length]
			for i := range m.Strings {
				m.Strings[i] = string((b.ReadString()))
			}
		}

	}
	return b.Err()
}
